package nl.inl.blacklab.search.lucene;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.TermStates;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.ScoreMode;
import org.apache.lucene.queries.spans.SpanWeight;

import nl.inl.blacklab.search.indexmetadata.RelationUtil;
import nl.inl.blacklab.search.results.QueryInfo;

/**
 * Captures all relations between the hits from two clauses.
 *
 * This is used to capture cross-field relations in a parallel corpus.
 *
 * @@@ PROBLEM: right now, subsequent spans from the source spans may not overlap!
 *   If they do overlap, some relations may be skipped over.
 *   We should cache some relations from the source span so we can be sure we return all
 *   of them, even if the source spans overlap.
 */
public class SpanQueryCaptureRelationsBetweenSpans extends BLSpanQueryAbstract {

    /** Target hits will have an autogenerated capture name with this suffix;
     *  we will omit them from the response (it is just the target hit, so
     *  doesn't need to be a separate match info) */
    public static final String TAG_MATCHINFO_TARGET_HIT = "__@target";

    /** Combination of relation and target queries */
    public static class Target {

        public static Target get(QueryInfo queryInfo, String relationFieldName, BLSpanQuery target, String targetField,
                String captureRelsAs, String relationType, boolean optionalMatch) {

            // Determine what relations to capture based on the class of the matching regex, if any
            String relClass = RelationUtil.classFromFullType(relationType);
            String anyType = relClass.isEmpty() ? RelationUtil.ANY_TYPE_REGEX :
                    RelationUtil.fullType(relClass, RelationUtil.ANY_TYPE_REGEX);

            return new Target(getRelationsQuery(queryInfo, relationFieldName, relationType),
                    getRelationsQuery(queryInfo, relationFieldName, anyType), target, targetField,
                    captureRelsAs, optionalMatch);
        }

        private static SpanQueryRelations getRelationsQuery(QueryInfo queryInfo, String relationFieldName,
                String relationType) {
            // Note that we use span mode source, because that's what we'll primarily be filtering on.
            // Once we find a relation matching the current source span, we'll check if target matches as well.
            SpanQueryRelations relations = new SpanQueryRelations(queryInfo, relationFieldName, relationType,
                    Collections.emptyMap(), SpanQueryRelations.Direction.BOTH_DIRECTIONS,
                    RelationInfo.SpanMode.SOURCE, "", null);
            return relations;
        }

        /** Relations to use for matching targets */
        private final BLSpanQuery matchRelations;

        /** Relations to capture with the hits (if we're e.g. finding alignments by sentence, we also want
         *  any word alignments in the results) */
        private final BLSpanQuery captureRelations;

        /** Match info name for the list of captured relations */
        private final String captureAs;

        /** Span the relation targets must overlap with (or null if we don't care)
         *  (Clause to the right of the ==> operator)
         */
        private final BLSpanQuery target;

        private final String targetField;

        /** Should we include the hit on the left side of the relation even if there's no hit on the right side? */
        private final boolean optionalMatch;

        private Target(BLSpanQuery matchRelations, BLSpanQuery captureRelations, BLSpanQuery target, String targetField,
                String captureAs, boolean optionalMatch) {
            this.matchRelations = matchRelations;
            this.captureRelations = captureRelations;
            this.target = target;
            this.targetField = targetField;
            this.captureAs = captureAs;
            this.optionalMatch = optionalMatch;
        }

        public static List<Target> rewriteTargets(List<Target> targets, IndexReader reader) throws IOException {
            boolean anyRewritten = false;
            List<Target> newTargets = new ArrayList<>(targets.size());
            for (Target target: targets) {
                Target newTarget = target.rewrite(reader);
                if (newTarget != target)
                    anyRewritten = true;
                newTargets.add(newTarget);
            }
            return anyRewritten ? newTargets : targets;
        }

        public static List<TargetWeight> createWeightTargets(List<Target> targets, IndexSearcher searcher, ScoreMode scoreMode, float boost)
                throws IOException {
            List<TargetWeight> targetWeights = new ArrayList<>(targets.size());
            for (Target target: targets) {
                TargetWeight targetWeight = target.createWeight(searcher, scoreMode, boost);
                targetWeights.add(targetWeight);
            }
            return targetWeights;
        }

        private TargetWeight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
            BLSpanWeight matchRelationsWeight = matchRelations.createWeight(searcher, scoreMode, boost);
            BLSpanWeight captureRelationsWeight = captureRelations.createWeight(searcher, scoreMode, boost);
            BLSpanWeight targetWeight = null;
            String captureTargetAs;

            // Are we explicitly capturing target, without any edge adjustments?
            if (target instanceof SpanQueryCaptureGroup && ((SpanQueryCaptureGroup) target).leftAdjust == 0 && ((SpanQueryCaptureGroup) target).rightAdjust == 0) {
                // Yes; remember the capture name, and strip the capture from the clause
                // (capturing will be done by SpansCaptureRelationsBetweenSpans)
                captureTargetAs = ((SpanQueryCaptureGroup) target).getCaptureName();
                BLSpanQuery targetClause = ((SpanQueryCaptureGroup) target).getClause();
                if (BLSpanQuery.isAnyNGram(targetClause)) {
                    // Special case: target is e.g. A:[]*. Don't actually search for all n-grams, just ignore
                    // target while matching relations and capture the relation targets as A.
                } else {
                    // Normal case: target is a real query. Create a weight for it.
                    targetWeight = targetClause.createWeight(searcher, scoreMode, boost);
                }
            } else {
                // Not explicitly capturing target; just create a weight for it.

                // tag this so it can be omitted from the response
                // (the only reason we're capturing it is so we know the correct "foreign hit" to
                //  return in the otherFields section of the response)
                captureTargetAs = captureAs + TAG_MATCHINFO_TARGET_HIT;
                targetWeight = target == null || BLSpanQuery.isAnyNGram(target) ? null :
                        target.createWeight(searcher, scoreMode, boost);
            }
            return new TargetWeight(matchRelationsWeight, captureRelationsWeight, targetWeight, captureAs,
                    captureTargetAs, targetField, optionalMatch);
        }

        private Target rewrite(IndexReader reader) throws IOException {
            BLSpanQuery newMatchRelations = matchRelations.rewrite(reader);
            BLSpanQuery newCaptureRelations = captureRelations.rewrite(reader);
            BLSpanQuery newTarget = target == null ? null : target.rewrite(reader);
            if (newMatchRelations != matchRelations || newCaptureRelations != captureRelations || newTarget != target) {
                return new Target(newMatchRelations, newCaptureRelations, newTarget, targetField, captureAs, optionalMatch);
            }
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            Target target1 = (Target) o;
            return optionalMatch == target1.optionalMatch && Objects.equals(matchRelations, target1.matchRelations)
                    && Objects.equals(captureRelations, target1.captureRelations) && Objects.equals(
                    captureAs, target1.captureAs) && Objects.equals(target, target1.target)
                    && Objects.equals(targetField, target1.targetField);
        }

        @Override
        public int hashCode() {
            return Objects.hash(matchRelations, captureRelations, captureAs, target, targetField, optionalMatch);
        }

        @Override
        public String toString() {
            return "Target{" +
                    "matchRelations=" + matchRelations +
                    ", captureRelations=" + captureRelations +
                    ", captureAs='" + captureAs + '\'' +
                    ", target=" + target +
                    '}';
        }
    }

    /** Combination of relation and target weights */
    static class TargetWeight {

        private final BLSpanWeight matchRelations;

        private final BLSpanWeight captureRelations;

        /** Match info name for the list of captured relations */
        private final String captureAs;

        /** Match info name for the target span (if target == null, and if desired) */
        private final String captureTargetAs;

        /** Target field for capture. */
        private final String targetField;

        /** Span the relation targets must be inside of (or null if we don't care) */
        private final BLSpanWeight target;

        /** Should we include the hit on the left side of the relation even if there's no hit on the right side? */
        private final boolean optionalMatch;

        public TargetWeight(BLSpanWeight matchRelations, BLSpanWeight captureRelations, BLSpanWeight target,
                String captureAs, String captureTargetAs, String targetField, boolean optionalMatch) {
            this.matchRelations = matchRelations;
            this.captureRelations = captureRelations;
            this.captureAs = captureAs;
            this.captureTargetAs = captureTargetAs;
            this.targetField = targetField;
            this.target = target;
            this.optionalMatch = optionalMatch;
        }

        public static boolean isCacheableTargets(List<TargetWeight> targets, LeafReaderContext ctx) {
            for (TargetWeight target: targets) {
                if (!target.isCacheable(ctx))
                    return false;
            }
            return true;
        }

        public static void extractTermStatesFromTargets(List<TargetWeight> targets, Map<Term, TermStates> contexts) {
            for (TargetWeight target: targets) {
                target.extractTermStates(contexts);
            }
        }

        public static List<SpansCaptureRelationsBetweenSpans.Target> getSpansTargets(List<TargetWeight> targets,
                LeafReaderContext context, SpanWeight.Postings requiredPostings)
                throws IOException {
            List<SpansCaptureRelationsBetweenSpans.Target> targetSpanses = new ArrayList<>(targets.size());
            for (TargetWeight target: targets) {
                SpansCaptureRelationsBetweenSpans.Target spansTarget = target.getSpans(context, requiredPostings);
                if (spansTarget == null && target.optionalMatch) {
                    // This is fine; optional target that has no matches. Just don't add the null value to the result,
                    // so the matching process will continue with the other targets (if any) that do have matches.
                } else {
                    // Target with matches, or a non-optional null target; add it to the targetSpanses.
                    targetSpanses.add(spansTarget); // if null, query has no hits at all; we'll check this later
                }
            }
            return targetSpanses;
        }

        private SpansCaptureRelationsBetweenSpans.Target getSpans(LeafReaderContext context,
                SpanWeight.Postings requiredPostings) throws IOException {
            BLSpans matchRelationsSpans = matchRelations.getSpans(context, requiredPostings);
            if (matchRelationsSpans == null)
                return null;
            BLSpans captureRelationsSpans = captureRelations.getSpans(context, requiredPostings);
            boolean hasTargetRestrictions = target != null;
            BLSpans targetSpans = hasTargetRestrictions ? target.getSpans(context, requiredPostings) : null;
            return new SpansCaptureRelationsBetweenSpans.Target(matchRelationsSpans, targetSpans, hasTargetRestrictions,
                    captureRelationsSpans, captureAs, captureTargetAs, targetField, optionalMatch);
        }

        private void extractTermStates(Map<Term, TermStates> contexts) {
            matchRelations.extractTermStates(contexts);
            captureRelations.extractTermStates(contexts);
            if (target != null)
                target.extractTermStates(contexts);
        }

        private boolean isCacheable(LeafReaderContext ctx) {
            return matchRelations.isCacheable(ctx) && (target == null || target.isCacheable(ctx));
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            TargetWeight that = (TargetWeight) o;
            return optionalMatch == that.optionalMatch && Objects.equals(matchRelations, that.matchRelations)
                    && Objects.equals(captureRelations, that.captureRelations) && Objects.equals(captureAs,
                    that.captureAs) && Objects.equals(captureTargetAs, that.captureTargetAs)
                    && Objects.equals(targetField, that.targetField) && Objects.equals(target, that.target);
        }

        @Override
        public int hashCode() {
            return Objects.hash(matchRelations, captureRelations, captureAs, captureTargetAs, targetField, target,
                    optionalMatch);
        }
    }

    private final List<Target> targets;

    /**
     * Capture all matching relations occurring within a captured span.
     * The query might be something like <code>'dog' within &lt;s/&gt;</code>.
     * In that case, captureRelsInside would be "s" (name of the capture containing the
     * sentence spans, automatically assigned).
     *
     * @param source        span the relation sources must be inside of
     * @param targets       spans the relation targets must be inside of (or null if we don't care)
     */
    public SpanQueryCaptureRelationsBetweenSpans(BLSpanQuery source, List<Target> targets) {
        super(source);
        this.targets = targets;
        this.guarantees = source.guarantees();
    }

    @Override
    public BLSpanQuery rewrite(IndexReader reader) throws IOException {
        List<BLSpanQuery> rewritten = rewriteClauses(reader);
        List<Target> newTargets = Target.rewriteTargets(targets, reader);
        if (rewritten == null && newTargets == targets)
            return this; // nothing to rewrite
        if (rewritten == null)
            rewritten = clauses;
        return new SpanQueryCaptureRelationsBetweenSpans(rewritten.get(0), newTargets);
    }

    @Override
    public boolean matchesEmptySequence() {
        return clauses.get(0).matchesEmptySequence();
    }

    @Override
    public BLSpanQuery noEmpty() {
        if (!matchesEmptySequence())
            return this;
        return new SpanQueryCaptureRelationsBetweenSpans(clauses.get(0).noEmpty(), targets);
    }

    @Override
    public BLSpanWeight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
        BLSpanWeight weight = clauses.get(0).createWeight(searcher, scoreMode, boost);
        List<TargetWeight> targetWeights = Target.createWeightTargets(targets, searcher, scoreMode, boost);
        return new Weight(weight, targetWeights, searcher, scoreMode.needsScores() ? getTermStates(weight) : null, boost);
    }

    public BLSpanQuery getClause() {
        return clauses.get(0);
    }

    class Weight extends BLSpanWeight {

        final BLSpanWeight sourceWeight;

        private final List<TargetWeight> targets;

        public Weight(BLSpanWeight sourceWeight, List<TargetWeight> targets,
                IndexSearcher searcher, Map<Term, TermStates> terms, float boost)
                throws IOException {
            super(SpanQueryCaptureRelationsBetweenSpans.this, searcher, terms, boost);
            this.sourceWeight = sourceWeight;
            this.targets = targets;
        }

        @Override
        public boolean isCacheable(LeafReaderContext ctx) {
            return sourceWeight.isCacheable(ctx) && TargetWeight.isCacheableTargets(targets, ctx);
        }

        @Override
        public void extractTermStates(Map<Term, TermStates> contexts) {
            sourceWeight.extractTermStates(contexts);
            TargetWeight.extractTermStatesFromTargets(targets, contexts);
        }

        @Override
        public BLSpans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
            BLSpans spans = sourceWeight.getSpans(context, requiredPostings);
            if (spans == null)
                return null;
            List<SpansCaptureRelationsBetweenSpans.Target> targetSpans =
                    TargetWeight.getSpansTargets(targets, context, requiredPostings);
            if (targetSpans.stream().anyMatch(Objects::isNull)) {
                return null; // one of the non-optional targets has no hits at all
            }
            if (targetSpans.isEmpty()) {
                // No targets; this means there were optional targets (==>? operator) without matches.
                // We still want to produce source hits in this case.
                return spans;
            }
            return new SpansCaptureRelationsBetweenSpans(spans, targetSpans);
        }

    }

    @Override
    public String toString(String field) {
        return "==>(" + clausesToString(field) + ", " + targets + ")";
    }

    @Override
    public long reverseMatchingCost(IndexReader reader) {
        return clauses.stream().mapToLong(clause -> clause.reverseMatchingCost(reader)).sum();
    }

    @Override
    public int forwardMatchingCost() {
        return clauses.stream().mapToInt(BLSpanQuery::forwardMatchingCost).sum();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        if (!super.equals(o))
            return false;
        SpanQueryCaptureRelationsBetweenSpans that = (SpanQueryCaptureRelationsBetweenSpans) o;
        return Objects.equals(targets, that.targets);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), targets);
    }
}
